#! /usr/bin/env bash

#       CREATED: 2021/02/05
# LAST MODIFIED: 2021/03/08
__version="0.4"


CONFIGFILE="$HOME/.config/gmi/config.conf"

_time() ( printf "%($1)T\\n" "-1" )

exec_editor() { "${EDITOR:-nano}" "$1"; }

__err() {
  local _type
  case $1 in
    E) _type="!! "; shift ;;
    M) _type=":: "; shift ;;
    W) _type="-- "; shift
  esac
  >&2 echo -e "${_type}$1"
}

read_param() {
  # return a value from the config file
  # for a given parameter.

  local __p __l regex
  __p="$1"
  [[ $__p ]] || { echo "null"; return 1; }
  regex="^[[:space:]]*${__p%=*}[[:space:]]*=([[:space:]]*)(.*)$"
  while read -r __l; do
    [[ $__l =~ ^#.*$ ]] && continue # ignore comments
    if [[ $__l =~ $regex ]]; then
      if [[ ! ${BASH_REMATCH[2]} ]]; then
        echo "null"
        return 1
      else
        echo "${BASH_REMATCH[2]//\~/$HOME}"
        return 0
      fi
    fi
  done < "$CONFIGFILE"
  echo "null"
  return 1
}

get_src_dir() {
  local dir value
  dir="source_dir"
  value="$(read_param "$dir")" || { __err E "missing directory [$dir]."; return 1; }
  [[ $value =~ .*/$ ]] || value+="/"
  echo "$value"
}

new() {
  # create a new article and
  # add it to index.gmi
  local tmpfile title entry_date
  tmpfile="$(mktemp)"
  title="${1:-"Sans titre"}"
  entry_date="$(_time "%_d %B %Y")"
  echo "# $title" > "$tmpfile"
  echo -e "\nLe$entry_date" >> "$tmpfile"
  local time1 time2
  time1="$(stat -c "%Y" "$tmpfile")"
  exec_editor "$tmpfile"
  time2="$(stat -c "%Y" "$tmpfile")"
  [[ $time1 == "$time2" ]] && {
    rm "$tmpfile"
    __err W "no change: file removed."
    return 1
  }
  title="$(get_title "$tmpfile")"
  local src d m y path index entry
  src="$(get_src_dir)" || return 1
  d="$(_time "%d")"
  m="$(_time "%m")"
  y="$(_time "%Y")"
  path="$y/$m/$d/"
  index=1
  [[ -d "${src}${path}" ]] || mkdir -p "${src}${path}"
  while [[ -a "${src}${path}${index}.gmi" ]]; do ((index++)); done
  entry="${src}${path}${index}.gmi"
  mv "$tmpfile" "$entry"
  __err M "saved entry: ${entry}."
  echo "=> ${path}${index}.gmi $y/$m/$d $title" >> "${src}index.gmi"
}

edit() {
  local entry
  entry="$1"
  [[ $entry == "index" ]] && {
    local src
    src="$(get_src_dir)"
    exec_editor "${src}index.gmi" || return 1
    return 0
  }
  [[ $entry == "micro" ]] && {
    local src
    src="$(get_src_dir)"
    exec_editor "${src}micro.gmi" || return 1
    return 0
  }
  [[ -a "$f" ]] && {
    local title1 title2
    title1="$(get_title "$entry")"
    exec_editor "$f" || return 1
    title2="$(get_title "$entry")"
    [[ $title2 != "$title1" ]] &&
      retitle_in "$entry" "$title2" || return 1
    return 0
  }
  __err E "$f: no such file."
  return 1
}

rss() {
local header item footer
header=$(cat << 'EOF'
<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title>[TITLE]</title>
<description>
[DESCRIPTION]
</description>
<link>[URL]</link>
<lastBuildDate>[DATE]</lastBuildDate>
EOF
)
item=$(cat << 'EOF'
<item>
<link>[URL]</link>
<pubDate>[DATE]</pubDate>
<title>[ITEMTITLE]</title>
<description>
[ITEMDESCRIPTION]
</description>
</item>
EOF
)
footer=$(cat << 'EOF'
</channel>
</rss>
EOF
)

  __err M "generating rss..."

  local title desc url
  title="$(read_param "rss_title")" || {
    __err E "config: rss_title missing."
    return 1
  }
  desc="$(read_param "rss_description")" || {
    __err E "config: rss_description missing."
    return 1
  }
  url="$(read_param "capsule_url")" || {
    __err E "config: capsule_url missing."
    return 1
  }

  local src index rssfile
  src="$(get_src_dir)" || return 1
  index="${src}index.gmi"
  [[ -s "$index" ]] || { __err E "index.gmi: no such file."; return 1; }
  rssfile="${src}feed/rss.xml"
  [[ -d "${src}feed" ]] || mkdir "${src}feed" || return 1
  
  local now
  now="$(_time "%F %T %Z")"
  header="${header/\[TITLE\]/$title}"
  header="${header/\[DATE\]/$now}"
  header="${header/\[URL\]/$url}"
  header="${header/\[DESCRIPTION\]/$desc}"

  echo "$header" > "$rssfile"

  local l newitem itemurl itemdate itemtitle
  while read -r l; do
    [[ $l =~ ^=\>\ (.+)\ ([0-9]{4}/[0-9]{2}/[0-9]{2})\ (.+)$ ]] && {
      newitem="$item"
      itemurl="$url/${BASH_REMATCH[1]}"
      itemdate="${BASH_REMATCH[2]}"
      itemtitle="${BASH_REMATCH[3]}"
      newitem="${newitem/\[URL\]/$itemurl}"
      newitem="${newitem/\[DATE\]/$itemdate}"
      newitem="${newitem/\[ITEMTITLE\]/$itemtitle}"
      newitem="${newitem/\[ITEMDESCRIPTION\]/$itemtitle}"
      echo "$newitem" >> "$rssfile"
    }
  done < <(tac "$index")

  echo "$footer" >> "$rssfile"

  __err M "rss generated."

}

get_title() {
  local f="$1"
  [[ -s "$f" ]] && {
    # shellcheck disable=SC2016
    sed -r 's_^# (.+)$_\1_;1q' "$f" 2> /dev/null || return 1
    return 0
  }
  return 1
}

retitle() {
  # rename an article via user input.
  local entry name T t
  entry="$1"
  name="${f##*/}"
  T="$(get_title "$entry")"
  read -i "$T" -p ":: $name: enter new title -> " -re t
  [[ $t ]] || return 1
  [[ $t == "$T" ]] && return 1
  retitle_in -f "$entry" "$t"
}


retitle_in() {
  # change title of an article.
  local src name entry newtitle force indexgmi
  src="$(get_src_dir)" || return 1
  [[ $1 == "-f" ]] && { force=1; shift; }
  entry="$1"
  newtitle="$2"
  name="${entry/$src/}"
  pdate="${name%/*.gmi}"
  name="${name%*.gmi}"
  [[ -a "$entry" ]] || { __err E "$name.gmi: no such file."; return 1; }
  [[ $force ]] && {
    sed -i "s_^# .*\$_# ${newtitle}_" "$entry"
    __err M "article $name renamed."
  }
  indexgmi="${src}index.gmi"
  [[ -a "$indexgmi" ]] || { __err E "index.gmi: no such file."; return 1; }
  sed -i "s_=> ${entry/$src/} ${pdate}.*_=> ${entry/$src} ${pdate} ${newtitle}_" "$indexgmi"
  __err M "article $name renamed in index.gmi."
}

delete_empty_dir() {
  [[ -a $(find "$1" -prune -type d -empty) ]] && {
    __err W "$dir appears to be empty."
    __err W "deleting..."
    rm -rf "$dir" && return 0
    return 1
  }
}

delete() {
  local src entry name dir title indexgmi
  src="$(get_src_dir)" || return 1
  entry="$1"
  name="${entry/$src}"
  dir="${entry%/*}"
  title="$(get_title "$entry")"
  [[ -a "$entry" ]] || { __err E "$name.gmi: no such file."; return 1; }
  indexgmi="${src}index.gmi"
  rm "$entry"
  __err M "$name deleted."
  sed -i "/^=> .*${title}.*$/d" "$indexgmi"
  __err M "$name removed from index.gmi."
  delete_empty_dir "$dir"
  return 0
}

confirm() {
  local r
  printf ":: sure? [y/N] -> "
  read -r r
  [[ ${r,,} == "y" ]] && return 0
  return 1
}

deploy() {
  local err src dst ssh_cmd ssh_id_file ssh_port
  src="$(get_src_dir)" || err=1;
  dst="$(read_param "server_destination_dir")" || { __err E "config: missing destination directory."; err=1; }
  [[ $err ]] && return 1
  [[ $dst =~ .*/$ ]] || dst+="/"
  [[ -d "$src" ]] || { __err E "$src; no such directory."; return 1; }
  ssh_port="$(read_param "ssh_port")" || unset ssh_port
  ssh_id_file="$(read_param "ssh_identity_file")" || unset ssh_id_file
  ssh_cmd="ssh"
  [[ $ssh_port ]] && ssh_cmd+=" -p $ssh_port"
  [[ $ssh_id_file ]] && ssh_cmd+=" -i $ssh_id_file"
  rss
  __err M "$src -> $dst"
  rsync -hruv --delete -e "$ssh_cmd" --rsync-path="sudo rsync" "$src" "$dst" || return 1
  __err M "deployed."
}

list() {
  local src f
  src="$(get_src_dir)"  || return 1
  f="$(
  (
      echo "new"
      echo "index"
      echo "micro"
      echo "post"
      find "$src" -regextype posix-extended -regex "^.*/[0-9]+\.gmi$" | sort
      echo "deploy"
      echo "cancel"
  ) | fzf +s --tac --header "gmi version $__version")"
  echo 
  case $f in
    new    ) new "$1"; return $? ;;
    index  ) edit index; return $? ;;
    micro  ) edit micro; return $? ;;
    post   ) post; return $? ;;
    deploy ) deploy; return $? ;;
    cancel ) return 0
  esac

  [[ $f ]] && {
    local title r
    title="$(get_title "$f")"
    __err M "${f#$src*}"
    __err M "$title"
    printf ":: [e]dit [r]ename [d]elete -> "
    read -r r
    case $r in
      d) confirm && delete "$f" ;;
      e) edit "$f" ;;
      r) retitle "$f" ;;
      *) __err M "aborted."
    esac
  }
}

post() {
  [[ $1 ]] ||  {
    local tmp
    local time1 time2
    tmp="$(mktemp)"
    time1="$(stat -c "%Y" "$tmp")"
    exec_editor "$tmp"
    time2="$(stat -c "%Y" "$tmp")"
    [[ $time1 == "$time2" ]] && {
      rm "$tmp"
      __err W "cancelled."
      return 1
    }
  }
  local now
  now="$(_time "%Y/%m/%d %H:%M")"
  local msg="${1:-"$(<"$tmp")"}"
  local src
  src="$(get_src_dir)"
  echo -e "## $now\n$msg\n" >> "${src}micro.gmi"
  [[ -a $tmp ]] && rm "$tmp"
  deploy
}

echo "gmi -- version $__version"
echo "This program is free software."
echo -e "It is distributed AS IS with NO WARRANTY.\n"

for opt in "$@"; do
  case $opt in
    index )  edit index; exit 0 ;;
    micro )  edit micro; exit 0 ;;
    new   )  shift; new "$1"; exit 0 ;;
    deploy)  deploy; exit 0 ;;
    post  )  shift; post "$1"; exit 0 ;;
  esac
done

list "$@"
